<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<link rel="stylesheet" type="text/css" href="css/selector.css"/>
</head>
<body>
<header>雷霆险胜灰熊</header>
<div class="content">
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>

<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
</div>

<div class="content">
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
</div>
<div class="content">
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
</div>
<div class="content">
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
</div>
<div class="content">
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
<p>雷霆险胜灰熊</p>
</div>
<div class="overflow">
在《深入理解Spark：核心思想与源码分析》一书中只是简单介绍了下RDD的checkpoint，对本书是个遗憾。所以此文的目的旨在查漏补缺，完善本书的内容。Spark的RDD执行完成之后会保存检查点，便于当整个作业运行失败重新运行时候，从检查点恢复之前已经运行成功的RDD结果，这样就会大大减少重新计算的成本，提高任务恢复效率和执行效率，节省Spark各个计算节点的资源。本文着重分析检查点的代码实现，更深入理解其原理。在《深入理解Spark：核心思想与源码分析》一书的第5章中讲到在获取RDD分区信息时会调用partitions方法（见代码清单5-11），在获取依赖时会调用dependencies方法（见代码清单5-28）。
</div>
<footer>雷霆险胜灰熊</footer>
</body>

</html>
